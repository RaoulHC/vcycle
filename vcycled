#!/usr/bin/python
#
# vcycled - VM lifecycle manager daemon for OpenStack etc
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2013-4. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#

import uuid
import sys
import getpass
import os
import tempfile
import random
import time
import shutil
import calendar
import novaclient.client

import VCYCLE

sleepSeconds      = 60
creationsPerCycle = 5

def cleanupDirectories(spaceName, serverNames):

  if not VCYCLE.spaces[spaceName]['delete_old_files']:
      return

  try:
      dirslist = os.listdir('/var/lib/vcycle/machines/')
  except:
      return
      
  # Go through the per-machine directories
  for onedir in dirslist:

      # Get the space name
      try:
        fileSpaceName = open('/var/lib/vcycle/machines/' + onedir + '/space_name', 'r').read().strip()
      except:
        continue

      # Ignore if not in this space, unless not in any defined space
      if fileSpaceName in VCYCLE.spaces and (fileSpaceName != spaceName):
        continue

      # Get the vmtype
      try:
        vmtypeName = open('/var/lib/vcycle/machines/' + onedir + '/vmtype_name', 'r').read().strip()
      except:
        continue

      try:
        onedirCtime = int(os.stat('/var/lib/vcycle/machines/' + onedir).st_ctime)
      except:
        continue
        
      # Ignore directories created in the last 60 minutes to avoid race conditions
      # (with other Vcycle instances? OpenStack latencies?)
      if onedirCtime > (time.time() - 3600):
        continue

      # If the VM still exists then no deletion either
      if onedir in serverNames:
        continue

      # Save machineoutputs if not done so already
      if vmtypeName in space['vmtypes'] and space['vmtypes'][vmtypeName]['log_machineoutputs']:
        VCYCLE.logLine('Saving machineoutputs to /var/lib/vcycle/machineoutputs/' + spaceName + '/' + vmtypeName + '/' + onedir)
        VCYCLE.logMachineoutputs(onedir, vmtypeName, spaceName)

      try:
        shutil.rmtree('/var/lib/vcycle/machines/' + onedir)
        VCYCLE.logLine('Deleted /var/lib/vcycle/machines/' + onedir + ' (' + fileSpaceName + ' ' + str(int(time.time()) - onedirCtime) + 's)')
      except:
        VCYCLE.logLine('Failed deleting /var/lib/vcycle/machines/' + onedir + ' (' + fileSpaceName + ' ' + str(int(time.time()) - onedirCtime) + 's)')

def cleanupMachineoutputs():

  try:
      spacesDirslist = os.listdir('/var/lib/vcycle/machinesoutputs/')
  except:
      return
      
  # Go through the per-machine directories
  for spaceDir in spacesDirslist:
  
      try:
           vmtypesDirslist = os.listdir('/var/lib/vcycle/machinesoutputs/' + spaceDir)
      except:
           continue

      for vmtypeDir in vmtypesDirslist:
        
           try:
                hostNamesDirslist = os.listdir('/var/lib/vcycle/machinesoutputs/' + spaceDir + '/' + vmtypeDir)
           except:
                continue
 
           for hostNameDir in hostNamesDirslist:
           
                hostNameDirCtime = int(os.stat('/var/lib/vcycle/machinesoutputs/' + spaceDir + '/' + vmtypeDir + '/' + hostNameDir).st_ctime)

                try: 
                     expirationDays = spaces[spaceName][vmtypeDir]['machineoutputs_days']
                except:
                     # use the default if something goes wrong (configuration file changed?)
                     expirationDays = 3.0
           
                if hostNameDirCtime < (time.time() - (86400 * expirationDays)):
                
                     try:
                          shutil.rmtree('/var/lib/vcycle/machinesoutputs/' + spaceDir + '/' + vmtypeDir + '/' + hostNameDir)
                          VCYCLE.logLine('Deleted /var/lib/vcycle/machinesoutputs/' + spaceDir + '/' + vmtypeDir + '/' + hostNameDir + ' (' + str((int(time.time()) - hostNameDirCtime)/86400.0) + ' days)')
                     except:
                          VCYCLE.logLine('Failed deleting /var/lib/vcycle/machinesoutputs/' + spaceDir + '/' + vmtypeDir + '/' + hostNameDir + ' (' + str((int(time.time()) - hostNameDirCtime)/86400.0) + ' days)')

def oneCycle(spaceName, space):

  VCYCLE.logLine('Processing space ' + spaceName)
  
  totalRunning = 0
  totalFound   = 0

  notPassedFizzleSeconds = {}
  foundPerVmtype         = {}
  runningPerVmtype       = {}
  weightedPerVmtype      = {}

  for vmtypeName,vmtype in space['vmtypes'].iteritems(): 
    notPassedFizzleSeconds[vmtypeName] = 0
    foundPerVmtype[vmtypeName]         = 0
    runningPerVmtype[vmtypeName]       = 0
    weightedPerVmtype[vmtypeName]      = 0.0
        
  novaClient = novaclient.client.Client('1.1', username=space['username'], api_key=space['password'],
                                        project_id=space['tenancy_name'], auth_url=space['url'],
                                        insecure=True)

  try:
    serversList = novaClient.servers.list(detailed=True)
  except Exception as e:
    VCYCLE.logLine('novaClient.servers.list() fails with exception ' + str(e))
    return

  serverNames = []

  for oneServer in serversList:

      # This includes VMs that we didn't create and won't manage, to avoid going above space limit
      totalFound += 1

      # Just in case other VMs are in this space
      if oneServer.name[:7] != 'vcycle-':
        continue

      serverNames.append(oneServer.name)

      try:
        fileSpaceName = open('/var/lib/vcycle/machines/' + oneServer.name + '/space_name', 'r').read().strip()
      except:
        # Not one of ours? Cleaned up directory too early?
        VCYCLE.logLine('Skipping ' + oneServer.name + ' which has no space name')
        continue
      else:
        # Weird inconsistency, maybe the name changed? So log a warning and ignore this VM
        if fileSpaceName != spaceName:        
          VCYCLE.logLine('Skipping ' + oneServer.name + ' which is in ' + space['space_name'] + ' but has space_name=' + fileSpaceName)
          continue

      try:
        vmtypeName = open('/var/lib/vcycle/machines/' + oneServer.name + '/vmtype_name', 'r').read().strip()
      except:
        # Something went wrong?
        VCYCLE.logLine('Skipping ' + oneServer.name + ' which has no vmtype name')
        continue

      if vmtypeName not in foundPerVmtype:
        foundPerVmtype[vmtypeName]  = 1
      else:
        foundPerVmtype[vmtypeName] += 1

      if (vmtypeName in weightedPerVmtype) and (VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['target_share'] > 0.0):
         weightedPerVmtype[vmtypeName] += (1.0 / VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['target_share'])

      createdTime  = calendar.timegm(time.strptime(oneServer.created, "%Y-%m-%dT%H:%M:%SZ"))
      updatedTime  = calendar.timegm(time.strptime(oneServer.updated, "%Y-%m-%dT%H:%M:%SZ"))
      
      taskState  = str(getattr(oneServer, 'OS-EXT-STS:task_state' ))
      powerState = str(getattr(oneServer, 'OS-EXT-STS:power_state'))

      try:
        launchedTime = calendar.timegm(time.strptime(str(getattr(oneServer,'OS-SRV-USG:launched_at')).split('.')[0], "%Y-%m-%dT%H:%M:%S"))
        startTime    = launchedTime
      except:
        launchedTime = None
        startTime    = createdTime        
      else:        
        if not os.path.isfile('/var/lib/vcycle/machines/' + oneServer.name + '/launched'):
          VCYCLE.createFile('/var/lib/vcycle/machines/' + oneServer.name + '/launched', str(launchedTime), 0600)
        
      try:
        ip = str(getattr(oneServer, 'addresses')['CERN_NETWORK'][0]['addr'])
      except:
        try:
          ip = str(getattr(oneServer, 'addresses')['novanetwork'][0]['addr'])
        except:
          ip = '0.0.0.0'
        
      try:
        heartbeatTime = int(os.stat('/var/lib/vcycle/machines/' + oneServer.name + '/machineoutputs/vm-heartbeat').st_ctime)
        heartbeatStr = str(int(time.time() - heartbeatTime)) + 's'
      except:
        heartbeatTime = None
        heartbeatStr = '-'
      
      VCYCLE.logLine(oneServer.name + ' ' + 
              (vmtypeName + '                  ')[:16] + 
              (ip + '            ')[:16] + 
              (oneServer.status + '       ')[:8] + 
              (taskState + '               ')[:13] +
              powerState + ' ' +
              oneServer.created + 
              ' to ' + 
              oneServer.updated + ' ' +
              ('%5.2f' % ((time.time() - startTime)/3600.0)) + ' ' +
              heartbeatStr)
              
      if oneServer.status == 'SHUTOFF'  and \
         vmtypeName in space['vmtypes'] and \
         (updatedTime - startTime) < space['vmtypes'][vmtypeName]['fizzle_seconds']:
        VCYCLE.logLine(oneServer.name + ' was a fizzle! ' + str(updatedTime - startTime) + ' seconds')
        try:
          VCYCLE.lastFizzles[spaceName][vmtypeName] = updatedTime
        except:
          # In case vmtype removed from configuration while VMs still existed
          pass

      if oneServer.status == 'ACTIVE' and powerState == '1':
        # These ones are running properly
        totalRunning += 1
        
        if vmtypeName not in runningPerVmtype:
          runningPerVmtype[vmtypeName]  = 1
        else:
          runningPerVmtype[vmtypeName] += 1

      # These ones are starting/running, but not yet passed space['vmtypes'][vmtypeName]['fizzle_seconds']
      if ((oneServer.status == 'ACTIVE' or 
           oneServer.status == 'BUILD') and 
          ((int(time.time()) - startTime) < space['vmtypes'][vmtypeName]['fizzle_seconds'])):
          
        if vmtypeName not in notPassedFizzleSeconds:
          notPassedFizzleSeconds[vmtypeName]  = 1
        else:
          notPassedFizzleSeconds[vmtypeName] += 1

      if ( 
           (
             # We always delete if in SHUTOFF state and not transitioning
             oneServer.status == 'SHUTOFF' and taskState == 'None'
           ) 
           or 
           (
             # We always delete if in ERROR state and not transitioning
             oneServer.status == 'ERROR' and taskState == 'None'
           ) 
           or 
           (
             # ACTIVE gets deleted if longer than max VM lifetime 
             oneServer.status == 'ACTIVE' and taskState == 'None' and ((int(time.time()) - startTime) > space['vmtypes'][vmtypeName]['max_wallclock_seconds'])
           )
           or 
           (
             # ACTIVE gets deleted if heartbeat defined in configuration but not updated by the VM
             'heartbeat_file'    in space['vmtypes'][vmtypeName] and
             'heartbeat_seconds' in space['vmtypes'][vmtypeName] and
             oneServer.status == 'ACTIVE' and taskState == 'None' and 
             ((int(time.time()) - startTime) > space['vmtypes'][vmtypeName]['heartbeat_seconds']) and
             (
              (heartbeatTime is None) or 
              ((int(time.time()) - heartbeatTime) > space['vmtypes'][vmtypeName]['heartbeat_seconds'])
             )              
           )
           or
           (
             (
               # Transitioning states ('deleting' etc) get deleted ...
               oneServer.status  == 'SHUTOFF' or
               oneServer.status  == 'ERROR'   or 
               oneServer.status  == 'DELETED' or 		   
               oneServer.status  == 'BUILD'   or 
               (oneServer.status == 'ACTIVE' and powerState != '1')
             )
             and
             (
               # ... but only if this has been for a while
               updatedTime < int(time.time()) - 900
             )             
           )
         ):
        VCYCLE.logLine('Deleting ' + oneServer.name)

        try:
          oneServer.delete()
        except Exception as e:
          VCYCLE.logLine('Delete ' + oneServer.name + ' fails with ' + str(e))

        if vmtypeName in space['vmtypes'] and space['vmtypes'][vmtypeName]['log_machineoutputs']:
          VCYCLE.logLine('Saving machineoutputs to /var/lib/vcycle/machineoutputs/' + spaceName + '/' + vmtypeName + '/' + oneServer.name)
          VCYCLE.logMachineoutputs(oneServer.name, vmtypeName, spaceName)

  VCYCLE.logLine('space ' + spaceName + ' has %d ACTIVE:running vcycle VMs out of %d found in any state for any vmtype or none' % (totalRunning, totalFound))

  for vmtypeName,vmtype in space['vmtypes'].iteritems():
    VCYCLE.logLine('vmtype ' + vmtypeName + ' has %d ACTIVE:running out of %d found in any state' % (runningPerVmtype[vmtypeName], foundPerVmtype[vmtypeName]))

  # Get rid of directories about old VMs
  
  cleanupDirectories(spaceName, serverNames)
  cleanupMachineoutputs()
  
  # Now decide whether to create new VMs

  creationsThisCycle = 0

  # Keep going till limits exhausted
  while True:
  
    if totalFound >= space['max_machines']:
      VCYCLE.logLine('Reached limit (%d) on number of machines to create for space %s' % (space['max_machines'], spaceName))
      return

    if creationsThisCycle >= creationsPerCycle:
      VCYCLE.logLine('Already reached limit of %d machine creations this cycle' % creationsThisCycle )
      return

    vmtypeNames = space['vmtypes'].keys()
    random.shuffle(vmtypeNames)

    # Go through vmtypes, finding the one to create (if any)
    vmtypeNameToCreate = None
  
    for vmtypeName in vmtypeNames:
      vmtype = space['vmtypes'][vmtypeName]

      if VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['target_share'] <= 0.0:
        # Skip over any vmtypes with no target share
        continue
    
      elif foundPerVmtype[vmtypeName] >= vmtype['max_machines']:
        VCYCLE.logLine('Reached limit (%d) on number of machines to create for vmtype %s' % (vmtype['max_machines'], vmtypeName))

      elif int(time.time()) < (VCYCLE.lastFizzles[spaceName][vmtypeName] + vmtype['backoff_seconds']):
        VCYCLE.logLine('Free capacity found for %s ... but only %d seconds after last fizzle' % (vmtypeName, int(time.time()) - VCYCLE.lastFizzles[spaceName][vmtypeName]) )
        
      elif (int(time.time()) < (VCYCLE.lastFizzles[spaceName][vmtypeName] + vmtype['backoff_seconds'] + vmtype['fizzle_seconds'])) and (notPassedFizzleSeconds[vmtypeName] > 0):
        VCYCLE.logLine('Free capacity found for %s ... but still within fizzleSeconds+backoffSeconds(%d) of last fizzle (%ds ago) and %d running but not yet passed fizzleSeconds (%d)' % 
               (vmtypeName, vmtype['fizzle_seconds'] + vmtype['backoff_seconds'], int(time.time()) - VCYCLE.lastFizzles[spaceName][vmtypeName], notPassedFizzleSeconds[vmtypeName], vmtype['fizzle_seconds']))

      elif vmtypeNameToCreate is None:
        vmtypeNameToCreate = vmtypeName
        
      elif weightedPerVmtype[vmtypeName] < weightedPerVmtype[vmtypeNameToCreate]:
        vmtypeNameToCreate = vmtypeName

    if vmtypeNameToCreate:
      VCYCLE.logLine('Free capacity found for ' + vmtypeNameToCreate + ' within ' + spaceName + ' ... creating')

      errorMessage = createMachine(novaClient, spaceName, vmtypeNameToCreate)

      creationsThisCycle += 1

      if errorMessage:
        VCYCLE.logLine(errorMessage)
      else:
        totalFound                                 += 1
        foundPerVmtype[vmtypeNameToCreate]         += 1
        notPassedFizzleSeconds[vmtypeNameToCreate] += 1
        weightedPerVmtype[vmtypeNameToCreate]      += (1.0 / VCYCLE.spaces[spaceName]['vmtypes'][vmtypeNameToCreate]['target_share'])

    else:
      VCYCLE.logLine('No more free capacity and/or suitable vmtype found within ' + spaceName)
      return

def createMachine(novaClient, spaceName, vmtypeName):
 
  serverName = 'vcycle-' + str(uuid.uuid4())
  os.makedirs('/var/lib/vcycle/machines/' + serverName + '/machinefeatures')
  os.makedirs('/var/lib/vcycle/machines/' + serverName + '/jobfeatures')
  os.makedirs('/var/lib/vcycle/machines/' + serverName + '/machineoutputs')

  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/vmtype_name', vmtypeName,  0644)
  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/space_name',  spaceName,   0644)

  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/machinefeatures/vac_vmtype',    vmtypeName, 0644)
  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/machinefeatures/vac_space',     spaceName,  0644)

  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/machinefeatures/phys_cores',    '1',        0644)
  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/machinefeatures/shutdown_time', str(int(time.time()) + VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['max_wallclock_seconds']), 0644)

  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/jobfeatures/cpu_limit_secs',  str(VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['max_wallclock_seconds']), 0644)
  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/jobfeatures/wall_limit_secs', str(VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['max_wallclock_seconds']), 0644)

  try:
    userDataContents = VCYCLE.getUserDataContents(spaceName, vmtypeName, serverName)
  except Exception as e:
    return 'Failed getting user_data file (' + str(e) + ')'

  try:
    newServer = novaClient.servers.create(serverName, 
          novaClient.images.find(name=VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['image_name']),
          novaClient.flavors.find(name=VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['flavor_name']), 
          key_name=VCYCLE.spaces[spaceName]['vmtypes'][vmtypeName]['root_key_name'],
          meta={ 'cern-services'   : 'false',
                 'machinefeatures' : 'http://'  + os.uname()[1] + '/' + serverName + '/machinefeatures',
                 'jobfeatures'     : 'http://'  + os.uname()[1] + '/' + serverName + '/jobfeatures',
                 'machineoutputs'  : 'https://' + os.uname()[1] + '/' + serverName + '/machineoutputs'
               }, 
          userdata=userDataContents)

  except Exception as e:
    return 'Error creating new server: ' + str(e)

  VCYCLE.createFile('/var/lib/vcycle/machines/' + serverName + '/machinefeatures/vac_uuid', newServer.id, 0644)

  VCYCLE.logLine('Created ' + serverName + ' (' + newServer.id + ') for ' + vmtypeName + ' within ' + spaceName)

  return None

#
# PROGRAM MAIN
#

if __name__ == '__main__':

  if (os.fork() != 0):
    sys.exit() # first parent

  else:
    os.chdir("/")
    os.setsid()
    os.umask(0) 

    if os.fork() != 0:
      sys.exit() # second parent

    else:

      try:
        f = open('/var/run/vcycled.pid', 'w')
        f.write(str(os.getpid()) + '\n')
        f.close()
      except:
        print 'Failed to create /var/run/vcycled.pid - exiting'
        sys.exit(1)

      # Close stdin now
      si = file('/dev/null', 'r')
      os.dup2(si.fileno(), sys.stdin.fileno())

      while True:

        # Close and reopen stdout->log file, in case of logrotate
        try:
          close(so)
        except:
          pass

        so = file('/var/log/vcycled', 'a+')
        os.dup2(so.fileno(), sys.stdout.fileno())
          
        # Close and reopen stderr->log file, in case of logrotate
        try:
          close(se)
        except:
          pass

        se = file('/var/log/vcycled', 'a+', 0)     
        os.dup2(se.fileno(), sys.stderr.fileno())

        try:
          pf = open('/var/run/vcycled.pid', 'r')
          pid = int(pf.read().strip())
          pf.close()
       
          if pid != os.getpid():
            print 'new /var/run/vcycled.pid - exiting'
            break
                
        except:
          print 'no /var/run/vcycled.pid - exiting'
          break

        VCYCLE.logLine('=============== Start cycle ===============')

        VCYCLE.logLine('readConf errors: ' + str(VCYCLE.readConf()))
        
        for spaceName, space in VCYCLE.spaces.iteritems():
          oneCycle(spaceName, space)
          
        VCYCLE.logLine('================ End cycle ================')

        # Flush logging to the filesystem 
        sys.stdout.flush()
        sys.stderr.flush()

        time.sleep(sleepSeconds)

      sys.exit(0) # if we break out of the while loop then we exit

